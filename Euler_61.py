'''
Euler Problem 61

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:

Triangle	 	                   P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 	                   P4,n=n2	                    	1, 4, 9, 16, 25, ...
Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

The set is cyclic, in that the last two digits of each number is the first two digits of the next number
(including the last number with the first).

Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882),
is represented by a different number in the set.

This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different
number in the set.
'''

triangleNums = []
squareNums = []
pentagonalNums = []
hexagonalNums = []
heptagonalNums = []
octagonalNums = []

for j in range(141):
    triangleNums += [j * (j+1) / 2]
    if j <100: squareNums += [j ** 2]
    if j <82: pentagonalNums += [j * (3 * j - 1) / 2]
    if j <71: hexagonalNums += [j * (2 * j - 1)]
    if j <64: heptagonalNums += [j * (5 * j - 3) / 2]
    if j <59: octagonalNums += [j * (3 * j - 2)]

rootNums = triangleNums + squareNums + pentagonalNums + hexagonalNums + heptagonalNums + octagonalNums
rootNums = sorted(rootNums)

def filterSet(numSet):
    hasOct = ''
    hasHep = ''
    hasHex = ''
    hasPen = ''
    hasSq = ''
    hasT = ''
    for row in numSet:
        for num in row:
                if int(num) in octagonalNums and hasOct == '':
                    hasOct = num
                    break
                elif int(num) in heptagonalNums and hasHep == '':
                    hasHep = num
                    break
                elif int(num) in hexagonalNums and hasHex == '':
                    hasHex = num
                    break
                elif int(num) in squareNums and hasSq == '':
                    hasSq = num
                    break
                elif int(num) in triangleNums and hasT == '':
                    hasT = num
                    break
                elif int(num) in pentagonalNums and hasPen == '':
                    hasPen = num
                    break
                    
    return  hasOct,hasHep,hasHex,hasPen,hasSq,hasT


def checkSet(s):
    numSet = s
    for k in range(len(numSet)):
        row = numSet[len(numSet) - k - 1]
    
        if k != len(numSet) - 1:
            previousRow = numSet[len(numSet) - k - 2]
        else:
            break
        
        prefixes = []           
        for num in row:
            prefix = num[:2]
            if prefix not in prefixes:
                prefixes += [prefix]

        rejects = []
        for num2 in previousRow:
            suffix = num2[2:]
            if suffix not in prefixes or num2 in octagonalNums:
                rejects += [num2]
        previousRow = [x for x in previousRow if x not in rejects]
        numSet[len(numSet) - k - 2] = previousRow

    sol = filterSet(numSet)
    fail = False
    for x in sol:
        if x == '':
            fail = True
    if not fail:
        print sol
        print sum([int(x) for x in sol])

def buildNumberSet(seed):
    term1 = str(seed)
    terms = [[term1]]
    prefix = term1[:2]
    suffix = term1[2:]
    global rootNums

    if seed in triangleNums:
        rootNums = [x for x in rootNums if x not in triangleNums]
    elif seed in squareNums:
        rootNums = [x for x in rootNums if x not in squareNums]
    elif seed in pentagonalNums:
        rootNums = [x for x in rootNums if x not in pentagonalNums]
    elif seed in hexagonalNums:
        rootNums = [x for x in rootNums if x not in hexagonalNums]
    elif seed in heptagonalNums:
        rootNums = [x for x in rootNums if x not in heptagonalNums]
    elif seed in octagonalNums:
        rootNums = [x for x in rootNums if x not in octagonalNums]

    for i in range(5):
        possibles = []
        for k in terms[-1]:
            suffix = k[2:]
            for num in rootNums:
                if num > 1000:
                    term = str(num)
                    t_prefix = str(term)[:2]
                    t_suffix = str(term)[2:]

                    if int(t_suffix) < 10:continue
                    if i == 4:
                        if t_suffix == prefix and t_prefix == suffix:
                            if term not in possibles:
                                possibles += [term]
                    elif t_prefix == suffix:
                        if term not in possibles:
                            possibles += [term]

        if len(possibles)>0:
            terms += [possibles]
    return terms

for k in octagonalNums:
    if k < 1000:
        continue
    s = buildNumberSet(k)
    checkSet(s)
